#include <HardwareSerial.h>
#include <ESP32-HUB75-MatrixPanel-I2S-DMA.h>
#include <FastLED.h>
#include <WebServer.h>
#include <ArduinoJson.h>
#include <Fonts/FreeMono9pt7b.h>
#pragma region Matrix Config
#define R1_PIN 25
#define G1_PIN 26
#define B1_PIN 27
#define R2_PIN 14
#define G2_PIN 12
#define B2_PIN 13
#define A_PIN 23
#define B_PIN 22 // Changed from library default
#define C_PIN 5
#define D_PIN 17
#define E_PIN 32 // required for 1/32 scan panels, like 64x64px. Any available pin would do, i.e. IO32
#define LAT_PIN 4
#define OE_PIN 15
#define CLK_PIN 16
// Configure for your panel(s) as appropriate!
#define PANEL_WIDTH 64
#define PANEL_HEIGHT 64
#define PANELS_NUMBER 2

#define PANE_WIDTH PANEL_WIDTH *PANELS_NUMBER
#define PANE_HEIGHT PANEL_HEIGHT
#define NUM_PIXELS PANE_WIDTH *PANE_HEIGHT
MatrixPanel_I2S_DMA *dma_display = nullptr;
// Another way of creating config structure
// Custom pin mapping for all pins
HUB75_I2S_CFG::i2s_pins _pins = {R1_PIN, G1_PIN, B1_PIN, R2_PIN, G2_PIN, B2_PIN, A_PIN, B_PIN, C_PIN, D_PIN, E_PIN, LAT_PIN, OE_PIN, CLK_PIN};
HUB75_I2S_CFG mxconfig(
    PANEL_WIDTH,           // width
    PANEL_HEIGHT,          // height
    PANELS_NUMBER,         // chain length
    _pins,                 // pin mapping
    HUB75_I2S_CFG::FM6126A // driver chip
);
#pragma endregion
const int bufferSize = 8192; // Kích thước bộ đệm tùy chỉnh
uint8_t buffer[bufferSize];
int bufferIndex = 0;
int numRows = 0;
int numCols = 0;
const int DATA_SIZE = 8192; // Số lượng phần tử trong mảng data
uint16_t data[DATA_SIZE];   // Mảng để lưu trữ dữ liệu RGB565
const int floatSize = sizeof(float);
static int x_moi = 0;
static int y_moi = 0;
int num_moi = 0;
bool reached = false;
bool gen_moi = false;
unsigned long period_time = millis();

const char CAT_bits[] PROGMEM = {
0xc8, 0x7c, 0x7c, 0x00, 0xc8, 0x7c, 0x7c, 0x00, 0xc8, 0x7c, 0x7c, 0x00, 0xc8, 0x7c, 0x7c, 0x00,
0x88, 0xfc, 0x3c, 0x00, 0x70, 0xbc, 0x5c, 0x00, 0x70, 0xbc, 0x5c, 0x00, 0x08, 0x7c, 0x3c, 0x00,
0x88, 0xfc, 0x3c, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0x08, 0x7c, 0x3c, 0x00, 0x50, 0x7c, 0x5c, 0x00, 0x08, 0xbc, 0x5c, 0x00, 0x48, 0xbc, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x48, 0xbc, 0xbc, 0x00, 0x28, 0x3c, 0xbc, 0x00, 0x48, 0xbc, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x68, 0x02, 0xbc, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0xff, 0x1f, 0x7f, 0x00, 0x85, 0x3b, 0x2b, 0x00, 0x5f, 0xcf, 0x9f, 0x00,
0x88, 0xfc, 0x3c, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x50, 0x7c, 0x5c, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0xff, 0x2f, 0xef, 0x00, 0x01, 0x8d, 0xb9, 0x00, 0x3f, 0xcf, 0x9f, 0x00, 0x70, 0xbc, 0x5c, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0x68, 0x02, 0x02, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x68, 0x02, 0x02, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0x51, 0x59, 0x79, 0x00, 0xb3, 0x39, 0x02, 0x00, 0xfd, 0x99, 0xda, 0x00,
0xfe, 0x15, 0xd9, 0x00, 0xdd, 0x33, 0xa3, 0x00, 0xdd, 0x33, 0xa3, 0x00, 0x03, 0xd3, 0x13, 0x00,
0x93, 0x15, 0x86, 0x00, 0xe3, 0x41, 0x44, 0x00, 0xff, 0x8f, 0x9f, 0x00, 0x48, 0xbc, 0xbc, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0xa8, 0x02, 0x02, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x25, 0x47, 0x0f, 0x00, 0x01, 0x95, 0x39, 0x00,
0x41, 0x15, 0xb9, 0x00, 0x21, 0x95, 0xf9, 0x00, 0x21, 0x55, 0xb9, 0x00, 0x21, 0x55, 0xb9, 0x00,
0x61, 0xd5, 0x39, 0x00, 0x95, 0x93, 0x23, 0x00, 0x08, 0xbc, 0x5c, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x28, 0x7c, 0x82, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x08, 0xdc, 0x9c, 0x00, 0xc1, 0x95, 0x79, 0x00,
0x61, 0x35, 0x85, 0x00, 0x61, 0x35, 0x85, 0x00, 0x91, 0xf5, 0x25, 0x00, 0x61, 0x35, 0x85, 0x00,
0x61, 0xd5, 0x79, 0x00, 0x90, 0x9c, 0x1c, 0x00, 0x08, 0xbc, 0x5c, 0x00, 0xc8, 0x7c, 0x7c, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x28, 0x7c, 0x82, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0xb9, 0x3b, 0x97, 0x00, 0x7d, 0x0b, 0xd3, 0x00,
0xcb, 0x0c, 0xe7, 0x00, 0xff, 0xcf, 0xef, 0x00, 0x91, 0xf5, 0x25, 0x00, 0x2b, 0x0c, 0x67, 0x00,
0x6d, 0xf3, 0x33, 0x00, 0xa5, 0x47, 0x8f, 0x00, 0x70, 0xbc, 0x5c, 0x00, 0xc8, 0x7c, 0x7c, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0x08, 0x7c, 0xdc, 0x00, 0xcf, 0x0f, 0xcf, 0x00, 0x10, 0x10, 0x10, 0x00,
0x39, 0xdb, 0x57, 0x00, 0x7e, 0x69, 0xe3, 0x00, 0x21, 0xb5, 0xe5, 0x00, 0x1f, 0x1f, 0x1f, 0x00,
0xb0, 0x30, 0xd0, 0x00, 0x7f, 0x1f, 0x6f, 0x00, 0xf0, 0x02, 0x3c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0x3c, 0xbc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0x48, 0x02, 0x7c, 0x00, 0xfe, 0x69, 0x29, 0x00, 0xe8, 0x28, 0x24, 0x00,
0x70, 0x30, 0x30, 0x00, 0x7c, 0xca, 0x90, 0x00, 0xdc, 0x6a, 0x90, 0x00, 0x70, 0x70, 0x70, 0x00,
0x90, 0xe0, 0x20, 0x00, 0xf9, 0x89, 0x75, 0x00, 0x88, 0x02, 0x3c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0x3c, 0xbc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00,
0x68, 0x42, 0x82, 0x00, 0xc8, 0x82, 0x02, 0x00, 0x08, 0x82, 0xbc, 0x00, 0x50, 0xbc, 0x1c, 0x00,
0x77, 0x77, 0xb7, 0x00, 0x2f, 0xb7, 0x17, 0x00, 0x8f, 0xb7, 0xa7, 0x00, 0x4f, 0x37, 0xd7, 0x00,
0x70, 0xc2, 0xbc, 0x00, 0x70, 0x82, 0xbc, 0x00, 0xc8, 0x82, 0x02, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00,
0xa8, 0x02, 0x02, 0x00, 0x88, 0x42, 0xfc, 0x00, 0xf0, 0x02, 0x3c, 0x00, 0xb1, 0x7c, 0x60, 0x00,
0x1c, 0xba, 0x79, 0x00, 0x99, 0x82, 0x40, 0x00, 0xd9, 0x82, 0x00, 0x00, 0x0c, 0xea, 0x59, 0x00,
0xc9, 0x7c, 0xa0, 0x00, 0x70, 0x82, 0xbc, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0xa8, 0x02, 0x02, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0x28, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0x02, 0x7c, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x28, 0x7c, 0x82, 0x00, 0x88, 0x7c, 0x7c, 0x00, 0x1f, 0x2f, 0xef, 0x00, 0x44, 0x58, 0x6c, 0x00,
0x74, 0x2a, 0x99, 0x00, 0x99, 0x82, 0x40, 0x00, 0x99, 0x82, 0x40, 0x00, 0x8f, 0xcf, 0xaf, 0x00,
0x44, 0x58, 0xac, 0x00, 0x7f, 0x5f, 0xbf, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0xa8, 0x7c, 0x7c, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x88, 0xfc, 0x3c, 0x00, 0xf0, 0x02, 0x3c, 0x00, 0xa0, 0x60, 0x80, 0x00, 0xef, 0xcf, 0x4f, 0x00,
0xa7, 0xb7, 0x57, 0x00, 0x99, 0x82, 0x40, 0x00, 0x39, 0x42, 0x80, 0x00, 0x34, 0x2a, 0x59, 0x00,
0x59, 0xc9, 0x6d, 0x00, 0x60, 0x80, 0xc0, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x48, 0xbc, 0xbc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x88, 0xfc, 0x3c, 0x00, 0x7d, 0x8b, 0x63, 0x00, 0x1d, 0x8b, 0xc3, 0x00, 0x30, 0x82, 0xec, 0x00,
0xc1, 0xa6, 0xa6, 0x00, 0xc3, 0xe9, 0x2e, 0x00, 0xa3, 0x69, 0x2e, 0x00, 0xfe, 0x06, 0xa6, 0x00,
0x08, 0x42, 0xdc, 0x00, 0x3f, 0x4f, 0xcf, 0x00, 0xbf, 0x4f, 0x4f, 0x00, 0x08, 0xbc, 0xdc, 0x00,
0xa8, 0xbc, 0x7c, 0x00, 0xa8, 0xfc, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0xbc, 0x7c, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x02, 0x02, 0x00, 0x28, 0x02, 0x7c, 0x00, 0x28, 0xfc, 0xfc, 0x00,
0x70, 0x7c, 0xdc, 0x00, 0xe1, 0xad, 0x79, 0x00, 0x21, 0x2d, 0x39, 0x00, 0x01, 0x99, 0xc9, 0x00,
0xbc, 0x86, 0x99, 0x00, 0xbc, 0x46, 0x69, 0x00, 0x3c, 0x86, 0xa9, 0x00, 0xbc, 0x06, 0x59, 0x00,
0xc4, 0x72, 0xd6, 0x00, 0x21, 0x6d, 0x99, 0x00, 0xe1, 0x2d, 0x39, 0x00, 0x3f, 0x0f, 0x4f, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xc8, 0xfc, 0xbc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x02, 0x02, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0xc8, 0xfc, 0x3c, 0x00, 0x6f, 0xf7, 0x0f, 0x00, 0x50, 0x2c, 0x4c, 0x00, 0x99, 0x55, 0x03, 0x00,
0xbc, 0xc6, 0xa9, 0x00, 0xbc, 0x46, 0xe9, 0x00, 0xbc, 0xc6, 0xa9, 0x00, 0x7c, 0xc6, 0x19, 0x00,
0xf9, 0xd5, 0xe3, 0x00, 0x08, 0xbc, 0x5c, 0x00, 0xfd, 0x97, 0xb7, 0x00, 0x70, 0xbc, 0x5c, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xc8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0x90, 0x00, 0x80, 0x00, 0x61, 0x85, 0x1b, 0x00, 0xe5, 0xcb, 0x07, 0x00, 0xdc, 0x7a, 0x69, 0x00,
0x7c, 0x86, 0x29, 0x00, 0x7e, 0x19, 0x53, 0x00, 0x7e, 0x19, 0x53, 0x00, 0xbc, 0xc6, 0xa9, 0x00,
0xdc, 0x7a, 0xe9, 0x00, 0x70, 0xbc, 0x5c, 0x00, 0x48, 0xbc, 0xbc, 0x00, 0x48, 0xbc, 0xbc, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0x70, 0x7c, 0xdc, 0x00, 0x59, 0xbb, 0x97, 0x00, 0xb0, 0x82, 0xdc, 0x00, 0xdd, 0x43, 0x07, 0x00,
0x6e, 0xf1, 0xd3, 0x00, 0x1e, 0xc9, 0xd3, 0x00, 0xde, 0x19, 0x53, 0x00, 0x7e, 0x19, 0x53, 0x00,
0x5d, 0x63, 0x07, 0x00, 0x08, 0xfc, 0x9c, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00,
0xc8, 0x82, 0x02, 0x00, 0x28, 0x82, 0x02, 0x00, 0x48, 0x42, 0xfc, 0x00, 0x33, 0x2b, 0x27, 0x00,
0x33, 0xf5, 0x81, 0x00, 0xa8, 0xe2, 0xbc, 0x00, 0x98, 0xe2, 0x42, 0x00, 0xd9, 0xc9, 0x6a, 0x00,
0x47, 0x8f, 0x37, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0xc8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x28, 0x3c, 0xbc, 0x00,
0xa8, 0x7c, 0x7c, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00, 0xa8, 0x02, 0x02, 0x00,
0x68, 0x42, 0x82, 0x00, 0xc8, 0x42, 0xfc, 0x00, 0x70, 0x82, 0xbc, 0x00, 0x46, 0x82, 0x98, 0x00,
0xf1, 0x1d, 0x25, 0x00, 0x58, 0xe2, 0x42, 0x00, 0xe8, 0x12, 0x22, 0x00, 0xa9, 0x83, 0xa5, 0x00,
0xc6, 0x82, 0x98, 0x00, 0x48, 0x02, 0xbc, 0x00, 0x88, 0xfc, 0x3c, 0x00, 0x68, 0xfc, 0xfc, 0x00,
0x68, 0xfc, 0xfc, 0x00, 0x68, 0x02, 0x7c, 0x00, 0x68, 0xfc, 0xfc, 0x00, 0x68, 0x3c, 0xbc, 0x00,
0x48, 0xbc, 0xbc, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0x28, 0xfc, 0xfc, 0x00, 0x88, 0xfc, 0x3c, 0x00,
0x28, 0xfc, 0xfc, 0x00, 0xc8, 0x82, 0x02, 0x00, 0x30, 0xc2, 0xfc, 0x00, 0xff, 0x5f, 0x7f, 0x00,
0xc8, 0x22, 0x82, 0x00, 0xe8, 0xe2, 0x62, 0x00, 0xe8, 0xe2, 0x62, 0x00, 0xa8, 0xa2, 0xfc, 0x00,
0x7f, 0x3f, 0xbf, 0x00, 0x08, 0x82, 0xbc, 0x00, 0xc8, 0x82, 0x02, 0x00, 0xa8, 0x7c, 0x7c, 0x00,
0xc8, 0x7c, 0x7c, 0x00, 0xc8, 0x7c, 0x7c, 0x00, 0x28, 0x3c, 0x7c, 0x00, 0x28, 0x3c, 0xbc, 0x00
};
uint32_t rgb565_to_rgb888(uint16_t rgb565) {
    // Tách các kênh màu từ giá trị RGB565
    uint8_t r = (rgb565 >> 11) & 0x1F;   // 5 bit cho đỏ
    uint8_t g = (rgb565 >> 5) & 0x3F;    // 6 bit cho xanh lục
    uint8_t b = rgb565 & 0x1F;           // 5 bit cho xanh dương

    // Chuyển đổi các kênh màu từ 5/6 bit sang 8 bit
    r = (r * 255 + 15) / 31;   // Chuyển đổi từ 5 bit sang 8 bit
    g = (g * 255 + 31) / 63;   // Chuyển đổi từ 6 bit sang 8 bit
    b = (b * 255 + 15) / 31;   // Chuyển đổi từ 5 bit sang 8 bit

    // Ghép các giá trị RGB888 thành một giá trị 32 bit
    return (r << 16) | (g << 8) | b;
}
void drawXbm565(int x, int y, int width, int height, const char *xbm, uint16_t color = 0xffff) 
{
  if (width % 8 != 0) {
      width =  ((width / 8) + 1) * 8;
  }
    for (int i = 0; i < width * height / 8; i++ ) {
      unsigned char charColumn = pgm_read_byte(xbm + i);
      for (int j = 0; j < 8; j++) {
        int targetX = (i * 8 + j) % width + x;
        int targetY = (8 * i / (width)) + y;
        if (bitRead(charColumn, j)) {
          dma_display->drawPixel(targetX, targetY, color);
        }
      }
    }
}

void draw_cat(int x_start, int y_start,int width, int height)
{
  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int index = (y * width + x);
      uint16_t color = (CAT_bits[index * 2] << 8) | CAT_bits[index * 2 + 1];
      uint32_t rgb888 = rgb565_to_rgb888(color);
      uint8_t r = (rgb888 >> 16) & 0xFF; // Kênh đỏ
      uint8_t g = (rgb888 >> 8) & 0xFF;  // Kênh xanh lục
      uint8_t b = rgb888 & 0xFF;         // Kênh xanh dương
      //dma_display->drawPixel(x, y, color);
      if (y <= 31)
        dma_display->drawPixelRGB888(x+x_start, y+y_start, r, g, b);
      else
        dma_display->drawPixelRGB888(x+x_start, y+y_start, r, b, g);
    }
  }
}

uint16_t rgbToUint16(uint8_t r, uint8_t g, uint8_t b, bool mode)
{
  if (mode)
  {
    uint16_t red = (r >> 3) & 0x1F;   // Chuyển từ 8 bit xuống 5 bit
    uint16_t green = (g >> 2) & 0x3F; // Chuyển từ 8 bit xuống 6 bit
    uint16_t blue = (b >> 3) & 0x1F;  // Chuyển từ 8 bit xuống 5 bit

    return (red << 11) | (green << 5) | blue;
  }
  else
  {
    uint16_t red = (r >> 3) & 0x1F;   // Chuyển từ 8 bit xuống 5 bit
    uint16_t green = (b >> 2) & 0x3F; // Chuyển từ 8 bit xuống 6 bit
    uint16_t blue = (g >> 3) & 0x1F;  // Chuyển từ 8 bit xuống 5 bit

    return (red << 11) | (green << 5) | blue;
  }
}
void draw_true_color(int x, int y, int r, int g, int b)
{
  if (y <= 31)
  {
    dma_display->drawPixelRGB888(x, y, r, g, b);
  }
  else
  {
    dma_display->drawPixelRGB888(x, y, r, b, g);
  }
}
// Hàm kiểm tra xem điểm (x, y) có đủ xa điểm (x_ref, y_ref) không
bool isFarEnough(int x, int x_ref, int min_distance)
{
  int dx = x - x_ref;
  return (dx * dx) >= (min_distance * min_distance);
}

// Hàm tạo điểm ngẫu nhiên không gần với điểm đã cho
void drawRandomPoint(int x_ref, int y_ref, int min_distance, bool generated)
{
  // int x, y;
  bool point_found = false;
  if (generated)
  {
    for (int i = x_moi - 1; i <= x_moi + 1; i++)
    {
      for (int j = y_moi - 1; j <= y_moi + 1; j++)
      {
        draw_true_color(i, j, 0, 0, 255);
      }
    }
  }
  else
  {
    while (!point_found)
    {
      x_moi = random(PANE_WIDTH);
      y_moi = y_ref;
      // Kiểm tra khoảng cách giữa điểm ngẫu nhiên và điểm đã cho
      if (isFarEnough(x_moi, x_ref, min_distance) && x_moi >= 32 && x_moi < 220)
      {
        point_found = true;
      }
    }
    for (int i = x_moi - 1; i < x_moi + 1; i++)
    {
      for (int j = y_moi - 1; j < y_moi + 1; j++)
      {
        draw_true_color(i, j, 0, 0, 255);
      }
    }
  }
}

int MinX_bar = 0;
int MaxX_bar = 5;
int MinY_bar = 50;
void Drawbar(int x)
{
  // measure x dimension
  int dodai = 16;
  MinX_bar = x-dodai/2;
  MaxX_bar = x+dodai/2;
  dma_display->drawLine(MinX_bar,MinY_bar-1,MaxX_bar,MinY_bar-1,dma_display->color333(3,3,3));
  dma_display->drawLine(MinX_bar,MinY_bar,MaxX_bar,MinY_bar,dma_display->color333(3,3,3));

}

bool created = false;
int X_vat = 20;
int Y_vat = 2;
int lastpoint[2];
int r = 2;
int speed = 500;
void DrawObject(bool deleted = false)
{
  // measure x dimension
  unsigned long now = millis();
  if (!created)
  {
    lastpoint[0]=X_vat;
    lastpoint[1]=Y_vat;
    dma_display->fillCircle(X_vat,Y_vat,r,dma_display->color333(0,0,0));
    dma_display->drawLine(MinX_bar,MinY_bar-1,MaxX_bar,MinY_bar-1,dma_display->color333(3,3,3));
    dma_display->drawLine(MinX_bar,MinY_bar,MaxX_bar,MinY_bar,dma_display->color333(3,3,3));

    X_vat = random(20, 109); // random(min, max), max không bao gồm
    Y_vat = 2;
    created = true;
  }
  else
  {
    if(now-period_time>=speed){
      dma_display->fillCircle(X_vat,Y_vat,r,dma_display->color333(0,0,0));
      Y_vat += 1;
      if (Y_vat > 52)created = false;
      period_time = now;
    }
  }

  //dma_display->drawCircle(X_vat,Y_vat,1,dma_display->color333(7,0,0));
  dma_display->fillCircle(X_vat,Y_vat,r,dma_display->color333(7,0,0));
}

int score = 0;
#define COLOR_BLACK dma_display->color333(0, 0, 0)
#define COLOR_WHITE dma_display->color333(7, 7, 7)
void HeldObject()
{
  if (Y_vat+r >= MinY_bar-1 && X_vat >= MinX_bar-r && X_vat <= MaxX_bar+r)
  {
    Serial.println("Created");
    created = false;
    //DrawObject(true);
    DrawObject();

    dma_display->setTextColor(COLOR_BLACK);
    dma_display->setCursor(2, 11);
    dma_display->printf("%d", score);
    score += 1;
    dma_display->setFont(&FreeMono9pt7b); // Change to the desired font size
    dma_display->setTextColor(COLOR_WHITE);
    
    dma_display->setCursor(2, 11);
    dma_display->printf("%d", score);
  }
  else{
    dma_display->setFont(&FreeMono9pt7b); // Change to the desired font size
    dma_display->setTextColor(COLOR_WHITE);
    dma_display->setCursor(2, 11);
    dma_display->printf("%d", score);
  }
}

// Stickman

int X_shot = 0;
int Y_shot = 32;
bool created_shot = false;
bool direction = false;
int lastpoint_shot[2];
unsigned long period_shot = millis();
int speed_shot = 300;
void Drawbullet(bool deleted = false)
{
  // measure x dimension
  unsigned long now = millis();
  if (!created_shot)
  {
    lastpoint_shot[0]=X_shot;
    lastpoint_shot[1]=Y_shot;
    dma_display->fillCircle(X_shot,Y_shot,1,dma_display->color333(0,0,0));
    int ran = random(1, 3);
    if (ran == 1)
    {
      X_shot = 1;
      direction = false;
    }
    else
    {
      X_shot = 126;
      direction = true;
    }
    created_shot = true;
    dma_display->fillCircle(X_shot,Y_shot,1,dma_display->color333(5,0,0));

  }
  else
  {
    if(now-period_shot>=speed_shot){
      dma_display->fillCircle(lastpoint_shot[0],lastpoint_shot[1],1,dma_display->color333(0,0,0));

      if (direction == false)
      {
        X_shot += 1;
        if (X_shot >= 126)
          created_shot = false;
      } 
      else{
        X_shot -= 1;
        if (X_shot <= 2)
          created_shot = false;
      } 
      lastpoint_shot[0]=X_shot;
      lastpoint_shot[1]=Y_shot;
      dma_display->fillCircle(X_shot,Y_shot,1,dma_display->color333(5,0,0));
      period_shot = now;
    }
  }
  //dma_display->drawCircle(X_vat,Y_vat,1,dma_display->color333(7,0,0));
  dma_display->fillCircle(X_vat,Y_vat,r,dma_display->color333(7,0,0));

}
void drawStickMan(int x, int y)
{
  // Vẽ đầu
  dma_display->drawCircle(x, y, 2, rgbToUint16(255, 0, 0, false)); // Đầu stick man

  // Vẽ thân
  dma_display->drawLine(x, y + 3, x, y + 7, rgbToUint16(255, 0, 0, false)); // Thân stick man

  // Vẽ tay
  dma_display->drawLine(x - 3, y + 4, x + 3, y + 4, rgbToUint16(255, 0, 0, false)); // Tay trái và tay phải
  // Vẽ chân
  dma_display->drawLine(x, y + 7, x - 3, y + 10, rgbToUint16(255, 0, 0, false)); // Chân trái
  dma_display->drawLine(x, y + 7, x + 3, y + 10, rgbToUint16(255, 0, 0, false)); // Chân phải

}
void setup()
{
  Serial.begin(115200 * 2); // Đảm bảo baud rate khớp với baud rate của Python
  dma_display = new MatrixPanel_I2S_DMA(mxconfig);
  dma_display->begin();            // setup the LED matrix
  dma_display->setBrightness8(50); // 0-255
  dma_display->clearScreen();
  //draw_cat(10,10,20,20);
  //drawXbm565(10,10,20,20,CAT_bits,dma_display->color565(100,0,0));
}

bool mode = false;
void loop()
{
  // server.handleClient();
#pragma region Serial processing
  while (Serial.available() > 0)
  {
    uint8_t byteReceived = Serial.read();
    if (bufferIndex < bufferSize)
    {
      buffer[bufferIndex++] = byteReceived;
    }
    else
    {
      // Xử lý tình huống quá tải
      Serial.println("Buffer overflow");
      bufferIndex = 0; // Reset buffer index in case of overflow
    }
  }
  
  float data[numRows][numCols];
  if (bufferIndex >= 2 * sizeof(int))
  {
    // Đã nhận đủ kích thước dữ liệu
    memcpy(&numRows, buffer, sizeof(int));
    memcpy(&numCols, buffer + sizeof(int), sizeof(int));

    

    int expectedSize = numRows * numCols * floatSize;

    if (bufferIndex >= (2 * sizeof(int) + expectedSize))
    {
      dma_display->clearScreen();
      
      for (int row = 0; row < numRows; ++row)
      {
        for (int col = 0; col < numCols; ++col)
        {
          int index = (2 * sizeof(int)) + (row * numCols + col) * floatSize;
          float value;
          memcpy(&value, &buffer[index], floatSize);
          data[row][col] = value;
        }
      }

      Drawbar(int(data[0][0]));
      
      

      // Reset chỉ số chỉ mục sau khi xử lý
      bufferIndex = 0;
    }
  }
  //DrawObject(true);
  DrawObject();
  HeldObject();
#pragma endregion

  // readDataFromSerial();
}

// int x = int(data[row][0]);
// int y = int(data[row][1]);
// int x_in = int(data[0][0]);
// int y_in = int(data[0][1]);

// if (x_in == 0 && y_in == 0)
// {
//   mode = true;
// }
// else if (x_in == 255 && y_in == 255)
// {
//   mode = false;
// }
// if (mode)
// {
//   int *_range;
//   _range = drawStickMan(x, y);
// }
// else
// {
//   // measure x dimension
//   int min_x = x - 1 - ((num_moi * 3) / 3);
//   int max_x = x + 1 + ((num_moi * 3) / 3);
//   int min_y = y - 1;
//   int max_y = y + 1;
//   for (int i = min_x; i <= max_x; i++)
//   {
//     for (int j = y - 1; j <= y + 1; j++)
//     {
//       if (j <= 32)
//         dma_display->drawPixelRGB888(i, j, 214, 24, 192);
//       else
//         dma_display->drawPixelRGB888(i, j, 214, 192, 24);
//       // reach moi
//       if (gen_moi == false && y<255)
//       {
//         drawRandomPoint(x, y, 5 + (num_moi * 3), false);

//         gen_moi = true;
//       }
//       if (min_x <= x_moi + 1 && max_x > x_moi - 1 && min_y <= y_moi + 1 && max_y >= y_moi - 1)
//       {
//         reached = true;
//         num_moi += 1;
//         gen_moi = false;
//       }
//     }
//   }
//   if (reached)
//   {
//     min_x = x - 1 - ((num_moi * 3) / 3);
//     max_x = x + 1 + ((num_moi * 3) / 3);
//     for (int i = min_x; i <= max_x; i++)
//     {
//       for (int j = y - 1; j <= y + 1; j++)
//       {
//         if (j <= 32)
//           dma_display->drawPixelRGB888(i, j, 214, 24, 192);
//         else
//           dma_display->drawPixelRGB888(i, j, 214, 192, 24);
//       }
//     }
//     reached = false;
//   }
//   if (gen_moi)
//   {
//     drawRandomPoint(x, y, 5 + (num_moi * 3), gen_moi);
//   }
// }